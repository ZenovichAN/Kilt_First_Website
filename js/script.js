'use strict';//чтобы весь код был в строгом режиме


        console.log(document)//выводим в консоль весь документ
        console.log(document.body)//выводим в консоль body

        console.dir(document)//выводим в консоль весь документ в виде дерева объектов
        
        // <script src="js/script.js" defer></script> - подключаем скрипт в html с отложенной загрузкой/* defer - загрузка скрипта после загрузки html, но до загрузки css


        // <script src="js/script.js" async></script> - подключаем скрипт в html с асинхронной загрузкой/* async - загрузка скрипта параллельно с загрузкой html и css, но не дожидаясь их загрузки. применяется для скриптов, которые не зависят от других скриптов и не влияют на отображение страницы. Например, для аналитики или рекламы. может загрузиться скрипт в любой момент, поэтому нужно быть осторожным с порядком загрузки скриптов. Например, если скрипт зависит от другого скрипта, то нужно использовать defer или загружать их в нужном порядке.

        console.log('item <body>: ',document.body) //выводим в консоль body

        console.log('parent item:' ,document.body.parentElement)//выводим в консоль родительский элемент body (html)

        console.log(document.previousElementSibling)//ссылка на предыдущий элемент (в данном случае это <head>)
        
        console.log(document.nextElementSibling)//ссылка на следующий элемент (в данном случае это null, так как нет следующего элемента после <html>)

        console.log(document.firstElementChild)//ссылка на первый элемент (в данном случае это <head>)

        console.log(document.children)//выводим в консоль все дочерние элементы (в данном случае это <head> и <body>)

        console.log(document.childNodes)//выводим в консоль все дочерние узлы (в данном случае это текстовый узел и <head> и <body>)
        console.log(document.firstChild)//выводим в консоль первый дочерний узел (в данном случае это текстовый узел)

        console.log(document.lastChild)//выводим в консоль последний дочерний узел (в данном случае это текстовый узел)

        console.log(document.lastElementChild)//выводим в консоль последний дочерний элемент (в данном случае это <body>)


 /** Поиск элементов getElement and querySelector */ //получаем статические коллекции элементов

 //.getElementById('id') - поиск элемента по id

//.getElementsByClassName('class') - поиск элементов по классу (возвращает HTMLCollection, который является живой коллекцией элементов, то есть при изменении DOM коллекция обновляется автоматически)

//.getElementsByTagName('tag') - поиск элементов по тегу (возвращает HTMLCollection, который является живой коллекцией элементов, то есть при изменении DOM коллекция обновляется автоматически)

//.querySelector('button') - поиск первого элемента по селектору (возвращает только один элемент, если элементов несколько, то возвращает первый найденный элемент)

//.querySelector('#button') - поиск элемента по id (возвращает только один элемент, если элементов несколько, то возвращает первый найденный элемент)

//.querySelector('.button') - поиск элемента по классу (возвращает только один элемент, если элементов несколько, то возвращает первый найденный элемент)

//.querySelectorAll('.button .list') - поиск всех элементов по селектору (возвращает NodeList, который не является живой коллекцией элементов, то есть при изменении DOM коллекция не обновляется автоматически)

//.querySelectorAll('selector').forEach((item) => {console.log(item)}) - перебор всех элементов по селектору (возвращает NodeList, который не является живой коллекцией элементов, то есть при изменении DOM коллекция не обновляется автоматически)

//console.log('button:' , myButton)//выводим в консоль элемент с id myButton. главное чтобы myButton был написан в camelCase


//.closest('selector') - поиск ближайшего родительского элемента по селектору (возвращает только один элемент, если элементов несколько, то возвращает первый найденный элемент). Например, если у нас есть элемент <div class="parent"><div class="child"></div></div>, то мы можем найти родительский элемент <div class="parent">, вызвав метод closest на дочернем элементе <div class="child">.

//.closest('.child') - поиск ближайшего родительского элемента с классом child (возвращает только один элемент, если элементов несколько, то возвращает первый найденный элемент). Например, если у нас есть элемент <div class="parent"><div class="child"></div></div>, то мы можем найти родительский элемент <div class="child">, вызвав метод closest на дочернем элементе <div class="child">.

//.closest('div') - поиск ближайшего родительского элемента с тегом div (возвращает только один элемент, если элементов несколько, то возвращает первый найденный элемент). Например, если у нас есть элемент <div class="parent"><div class="child"></div></div>, то мы можем найти родительский элемент <div class="parent">, вызвав метод closest на дочернем элементе <div class="child">.

//.closest('.parent') - поиск ближайшего родительского элемента с классом parent (возвращает только один элемент, если элементов несколько, то возвращает первый найденный элемент). Например, если у нас есть элемент <div class="parent"><div class="child"></div></div>, то мы можем найти родительский элемент <div class="parent">, вызвав метод closest на дочернем элементе <div class="child">.
 
///////////////////////////////////////////////////////////////////////////////////////////////
//немного забытых и непонятных методов. они возвращают живые коллекции

//.getElementsByName('name') - поиск элементов по имени (возвращает HTMLCollection, который является живой коллекцией элементов, то есть при изменении DOM коллекция обновляется автоматически). Например, если у нас есть элемент <input name="name">, то мы можем найти его, вызвав метод getElementsByName('name').

//.getElementsByName('name')[0] - поиск первого элемента по имени (возвращает только один элемент, если элементов несколько, то возвращает первый найденный элемент). Например, если у нас есть элемент <input name="name">, то мы можем найти его, вызвав метод getElementsByName('name')[0].

//getElementsByTagName('tag')[0] - поиск первого элемента по тегу (возвращает только один элемент, если элементов несколько, то возвращает первый найденный элемент). Например, если у нас есть элемент <input name="name">, то мы можем найти его, вызвав метод getElementsByTagName('input')[0].

//getElementsByClassName('class')[0] - поиск первого элемента по классу (возвращает только один элемент, если элементов несколько, то возвращает первый найденный элемент). Например, если у нас есть элемент <input name="name">, то мы можем найти его, вызвав метод getElementsByClassName('input')[0].




/** чтобы не допускать путаницу и более точно обращаться к элементам, лучше использовать data */

//<div class = "slider" data-js-slider></div>
//<div class = "slider__list" data-js-slider-list></div>
//<div class = "slider__slide" data-js-slider -slide></div>
//const slider = document.querySelector('[data-js-slider]')//поиск элемента по data-атрибуту
//const sliderList = document.querySelector('[data-js-slider-list]')//поиск элемента по data-атрибуту

// data-атрибуты - это атрибуты, которые начинаются с data- и могут быть использованы для хранения пользовательских данных. Например, если у нас есть элемент <div data-id="1">, то мы можем получить его значение, вызвав метод dataset.id. Также можно использовать метод setAttribute для установки значения data-атрибута. Например, если у нас есть элемент <div data-id="1">, то мы можем установить его значение, вызвав метод setAttribute('data-id', '2').

//.dataset - это объект, который содержит все data-атрибуты элемента. Например, если у нас есть элемент <div data-id="1" data-name="name">, то мы можем получить его значение, вызвав метод dataset.id и dataset.name. Также можно использовать метод setAttribute для установки значения data-атрибута. Например, если у нас есть элемент <div data-id="1" data-name="name">, то мы можем установить его значение, вызвав метод setAttribute('data-id', '2') и setAttribute('data-name', 'newName').